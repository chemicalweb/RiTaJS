[
	{
      "methodName":"generateTokens()",
      "example":"",
      "description":"Generates a string of <pre>length</pre> tokens from the model",
      "syntax":"generateTokens(int targetNumber)",
      "parameters":
      [
			{ 
			"type": "int", 
			"desc": "the target number of tokens to generate" 
			}
			
	  ],
	  "returns":
      [
			{ 
			"type": "String[]", 
			"desc": "strings" 
			}
			
	  ],
      "related":"",
      "platform":"Java / Javascript",
	  "note":""
   },
   {
      "methodName":"generateUntil()",
      "example":"",
      "description":"Continues generating tokens until a token matches 'regex', assuming the length of the output array is between min and maxLength (inclusive).",
      "syntax":"generateUntil(String regex, number minLength, number maxLength)<br/>generateUntil(object regex, number minLength, number maxLength)",
      "parameters":
      [
			{ 
			"type": "String", 
			"desc": "name" 
			},
			{ 
			"type": "int", 
			"desc": "the minimum number of tokens to generate" 
			},
			{ 
			"type": "int", 
			"desc": "the maximum number of tokens to generate" 
			}
			
	  ],
	  "returns":
      [
			{ 
			"type": "String[]", 
			"desc": "strings" 
			}
			
	  ],
      "related":"",
      "platform":"Java / Javascript",
	  "note":""
   },
   {
      "methodName":"generateSentences()",
      "example":"",
      "description":"Generates some # (one or more) of sentences from the model.<br/><br/>Note: multiple sentences generated by this method WILL follow the model across sentence boundaries; thus the following two calls are NOT equivalent:<br/><pre>String[] results = markov.generateSentences(10);<br/>  and<br/>for (int i = 0; i < 10; i++)<br/>  results[i] = markov.generateSentence(1);</pre>The latter will create 10 sentences with no explicit relationship between one and the next; while the former will follow probabilities from one sentence (across a boundary) to the next.",
      "syntax":"generateSentences(int num)",
      "parameters":
      [
			{ 
			"type": "int", 
			"desc": "" 
			}
			
	  ],
	  "returns":
      [
			{ 
			"type": "String[]", 
			"desc": "strings" 
			}
			
	  ],
      "related":"",
      "platform":"Java / Javascript",
	  "note":""
   },
   {
      "methodName":"getCompletions()",
      "example":"var result = rm.getCompletions([ &#34;the&#34;,&#34;red&#34;]);<br/><br/>If two arrays are provided, it returns an unordered list of possible words <i>w</i> that complete an n-gram consisting of: pre[0]...pre[k], <i>w</i>, post[k+1]...post[n].<br/><br/>var result = rm.getCompletions([ &#34;the&#34; ], [ &#34;red&#34;, &#34;ball&#34; ]);<br/><br/>will return all the single words that occur between 'the' and 'red ball' in the current model (assuming n > 3),<br/>e.g., [ 'round', 'big', 'bouncy']).<br/><br/>Note: For this operation to be valid, (pre.length + post.length) must be less than the model's n-factor, otherwise an error will be thrown. ",
      "description":"If only one array parameter is provided, this function returns all possible next words (or tokens), ordered by probability, for the given array. <br/><br/>Note: seed arrays of any size (>0) may be input, but only the last n-1 elements will be considered.",
      "syntax":"getCompletions(String[] pre)<br/>getCompletions(String[] pre, String[] post)",
      "parameters":
      [
			{ 
			"type": "String[]", 
			"desc": "pre" 
			},
			{ 
			"type": "String[]", 
			"desc": "post" 
			}
			
	  ],
	  "returns":
      [
			{ 
			"type": "String[]", 
			"desc": "an unordered list of possible next tokens" 
			}
			
	  ],
      "related":"",
      "platform":"Java / Javascript",
	  "note":""
   },
   {
      "methodName":"getN()",
      "example":"",
      "description":"Returns the current n-value for the model",
      "syntax":"getN()",
      "parameters":
      [
			{ 
			"type": "None", 
			"desc": "" 
			}

			
	  ],
	  "returns":
      [
			{ 
			"type": "int", 
			"desc": "" 
			}
			
	  ],
      "related":"",
      "platform":"Java / Javascript",
	  "note":""
   },
      {
      "methodName":"getProbabilities()",
      "example":"",
      "description":"Returns the full set of possible next tokens, as an associative array, (mapping string -> number (probability)) given an array of tokens representing the path down the tree (with length less than n).<br/><br/>Note: seed arrays of any size (>0) may be input, but only the last n-1 elements will be considered.   ",
      "syntax":"getProbabilities(String path)<br/>getProbabilities(String[] path)",
      "parameters":
      [
			{ 
			"type": "String OR Sting[]", 
			"desc": "a single token or array of tokens (strings)" 
			}

			
	  ],
	  "returns":
      [
			{ 
			"type": "Map", 
			"desc": "associative array mapping tokens to probabilities" 
			}
			
	  ],
      "related":"",
      "platform":"Java / Javascript",
	  "note":""
   },
   {
      "methodName":"getProbability()",
      "example":"",
      "description":"Returns either the raw (unigram) probability for a single token in the model (0 if it does not exist) <br/>OR (for an array) the probability of obtaining a sequence of k tokens where k <= nFactor,<br/>e.g., if nFactor = 3, then valid lengths for the data arrau are 1, 2 & 3.",
      "syntax":"getProbability(String data)<br/>getProbabilities(String[] data)",
      "parameters":
      [
			{ 
			"type": "String OR Sting[]", 
			"desc": "the string (or sequence of strings) to search for" 
			}

			
	  ],
	  "returns":
      [
			{ 
			"type": "float", 
			"desc": "from 0-1" 
			}
			
	  ],
      "related":"",
      "platform":"Java / Javascript",
	  "note":""
   },
   {
      "methodName":"loadTokens()",
      "example":"",
      "description":"Loads an array of tokens (or words) into the model; <br/>each element in the array must be a single token for proper construction of the model. ",
      "syntax":"loadTokens(String[] tokens)<br/>loadTokens(String[] tokens, number multiplier)",
      "parameters":
      [
			{ 
			"type": "Sting[]", 
			"desc": "tokens the strings with which to load the model" 
			},
			{ 
			"type": "int", 
			"desc": "Weighting for tokens in the array (optional, default=1)" 
			}
	
	  ],
	  "returns":
      [
			{ 
			"type": "RiMarkov", 
			"desc": "this RiMarkov" 
			}
			
	  ],
      "related":"",
      "platform":"Java / Javascript",
	  "note":""
   },
   {
      "methodName":"loadText()",
      "example":"",
      "description":"Loads a text string into the model after tokenizing it.",
      "syntax":"loadText(String text)<br/>loadText(String text, number multiplier)<br/>loadText(String text, number multiplier, String regex)",
      "parameters":
      [
			{ 
			"type": "Sting", 
			"desc": "the string" 
			},
			{ 
			"type": "int", 
			"desc": "Weighting for text (optional, default=1) " 
			},
						{ 
			"type": "String", 
			"desc": "a regular expression to be used for tokenizing (optional, if not supplied, uses RiTa.tokenize())" 
			}
	
	  ],
	  "returns":
      [
			{ 
			"type": "RiMarkov", 
			"desc": "this RiMarkov" 
			}
			
	  ],
      "related":"",
      "platform":"Java / Javascript",
	  "note":""
   },
   {
      "methodName":"ignoreCase()",
      "example":"",
      "description":"",
      "syntax":"ignoreCase()",
      "parameters":
      [
			{ 
			"type": "", 
			"desc": "" 
			}

	  ],
	  "returns":
      [
			{ 
			"type": "", 
			"desc": "" 
			}
			
	  ],
      "related":"",
      "platform":"Java / Javascript",
	  "note":""
   },
      {
      "methodName":"print()",
      "example":"",
      "description":"Prints a formatted version of the model to the console ",
      "syntax":"print()",
      "parameters":
      [
			{ 
			"type": "None", 
			"desc": "" 
			}

	  ],
	  "returns":
      [
			{ 
			"type": "RiMarkov", 
			"desc": "this RiMarkov" 
			}
			
	  ],
      "related":"",
      "platform":"Java / Javascript",
	  "note":""
   },
   {
      "methodName":"recognizeSentences()",
      "example":"",
      "description":"Sets whether the model will try to recognize (english-like) sentences in its input (default=true).<br/><br/>Note: should be called before any data loading is done.",
      "syntax":"recognizeSentences()<br/>recognizeSentences(boolean value)",
      "parameters":
      [
			{ 
			"type": "boolean", 
			"desc": "the value(optional, for sets only)" 
			}

	  ],
	  "returns":
      [
			{ 
			"type": "RiMarkov OR boolean", 
			"desc": "" 
			}
			
	  ],
      "related":"",
      "platform":"Java / Javascript",
	  "note":""
   },
   {
      "methodName":"size()",
      "example":"",
      "description":"Returns the number of tokens currently in the model",
      "syntax":"size()",
      "parameters":
      [
			{ 
			"type": "None", 
			"desc": "" 
			}

	  ],
	  "returns":
      [
			{ 
			"type": "int", 
			"desc": "" 
			}
	  ],
      "related":"",
      "platform":"Java / Javascript",
	  "note":""
   },
   {
      "methodName":"useSmoothing()",
      "example":"",
      "description":"Sets/gets the value of 'useSmoothing' to detemine whether (add-1) smoothing is enabled for the model.<br/><br/>Note: should be called before any data loading is done.",
      "syntax":"useSmoothing()<br/>useSmoothing(boolean)",
      "parameters":
      [
			{ 
			"type": "boolean", 
			"desc": "the value (optional, for sets only)" 
			}

	  ],
	  "returns":
      [
			{ 
			"type": "RiMarkov OR boolean", 
			"desc": "" 
			}
			
	  ],
      "related":"",
      "platform":"Java / Javascript",
	  "note":""
   }
]