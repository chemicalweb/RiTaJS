<!-- $Id: RiTa-syllabify-test.html,v 1.1 2012/06/29 06:12:23 dev Exp $ -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<link rel="stylesheet" href="rita-test.css" type="text/css" media="screen"/>
<script type="text/javascript" src="../../lib/jquery.js"></script>
<script type="text/javascript" src="../../lib/qunit-git.js"></script>
<script type="text/javascript" src="../rita.js"></script>
<script>

var None = undefined;

//function last(word) {
//    return word.charAt(word.length-1);
//}
//
//function extend(l1,l2) {
//    for (var i = 0; i < l2.length; i++) 
//        l1.push(l2[i]);
//}
//
//function isdigit(n) {
//    return !isNaN(parseFloat(n)) && isFinite(n);
//}
//
//function join(c,list) {
//    var str = '';
//    for (var i = 0; i < list.length; i++) {
//        str += list[i];
//        if (i < list.length-1) str += c;
//    }
//    return str;
//}
//
//function inArray(array, val) {
//    
//    var i = array.length;
//    while (i--) {
//        if (array[i] == val) {
//            return true;
//        }
//    }
//    return false;
//}

/**
 *  Syllabifies the word, given a string of phonemes from the CMU pronouncing dictionary set
 *   (with optional stress numbers after vowels), or an array of phonemes,  e.g. "B AE1 T" or ["B", "AE1", "T"]'''
 *       
 *  @param {string or array} input containing
 *  @returns {string} 

function syllabify(input) {
 
    if (typeof syllabify.phoneset == 'undefined') {
        syllabify.phoneset = {
            
            consonants: ['B', 'CH', 'D', 'DH', 'F', 'G', 'HH', 'JH', 'K', 'L', 'M', 'N', 
                   'NG', 'P', 'R', 'S', 'SH', 'T', 'TH', 'V', 'W', 'Y', 'Z', 'ZH'],

            vowels: [ 'AA', 'AE', 'AH', 'AO', 'AW', 'AY', 'EH', 'ER', 'EY', 'IH', 'IY', 'OW', 'OY', 'UH', 'UW'],

            onsets: ['P', 'T', 'K', 'B', 'D', 'G', 'F', 'V', 'TH', 'DH', 'S', 'Z', 'SH', 'CH', 'JH', 'M',
                  'N', 'R', 'L', 'HH', 'W', 'Y', 'P R', 'T R', 'K R', 'B R', 'D R', 'G R', 'F R',
                  'TH R', 'SH R', 'P L', 'K L', 'B L', 'G L', 'F L', 'S L', 'T W', 'K W', 'D W', 
                  'S W', 'S P', 'S T', 'S K', 'S F', 'S M', 'S N', 'G W', 'SH W', 'S P R', 'S P L',
                  'S T R', 'S K R', 'S K W', 'S K L', 'TH W', 'ZH', 'P Y', 'K Y', 'B Y', 'F Y', 
                  'HH Y', 'V Y', 'TH Y', 'M Y', 'S P Y', 'S K Y', 'G Y', 'HH W', '']
        }
    } 
        
    var dbug = 0;

    if(dbug) console.log('syllabify:'+word);
    
    var internuclei = [], syllables = [],   // returned data structure.
        sylls = ((typeof (input) == 'string') ? input.split('-') : input);

    for (var i = 0; i < sylls.length; i++) {
    
        var phoneme = sylls[i].trim(), stress = None;

        if (!phoneme.length) continue;
        
        if ( isdigit(last(phoneme)) ) {
            
            stress = parseInt(last(phoneme));
            phoneme = phoneme.substring(0, phoneme.length-1);
        }
        
        if(dbug)console.log(i+")"+phoneme + ' stress='+stress+' inter='+internuclei.join(':'));
        
        if (inArray(syllabify.phoneset.vowels, phoneme)) {
 
            // Split the consonants seen since the last nucleus into coda and onset.            
            var coda = None, onset = None;
            
            // Make the largest onset we can. The 'split' variable marks the break point.
            for (var split = 0; split < internuclei.length+1; split++) {
                
                coda  = internuclei.slice(0, split);
                onset = internuclei.slice(split, internuclei.length);
                
                if(dbug)console.log('  '+split+') onset='+onset.join(':')+'  coda='+coda.join(':')+'  inter='+internuclei.join(':'));
                
                // If we are looking at a valid onset, or if we're at the start of the word
                // (in which case an invalid onset is better than a coda that doesn't follow
                // a nucleus), or if we've gone through all of the onsets and we didn't find
                // any that are valid, then split the nonvowels we've seen at this location.
                var bool = inArray(syllabify.phoneset.onsets, onset.join(" "));
                if (bool || syllables.length == 0 || onset.length == 0) {
                    if(dbug)console.log('  break '+phoneme);
                   break;
                }
            }
            
            //if(dbug)console.log('  onset='+join(',',onset)+'  coda='+join(',',coda));
            
            // Tack the coda onto the coda of the last syllable. Can't do it if this
            // is the first syllable.
            if (syllables.length > 0 ) {
                
                //syllables[syllables.length-1][3] = syllables[syllables.length-1][3] || [];
                //console.log('  len='+syllables[syllables.length-1][3].length);
                extend(syllables[syllables.length-1][3], coda);
                if(dbug)console.log('  tack: '+coda+' -> len='+syllables[syllables.length-1][3].length+" ["+syllables[syllables.length-1][3]+"]");
            }
            
            // Make a new syllable out of the onset and nucleus.

            var toPush = [ [stress], onset, [phoneme], [] ];
            syllables.push(toPush);
                
            // At this point we've processed the internuclei list.
            internuclei = [];
        }
        
        else if (!inArray(syllabify.phoneset.consonants, phoneme) && phoneme != " ") {
            throw Error('Invalid phoneme: ' + phoneme);
        }
            
        else { // a consonant
            
            //console.log('inter.push: '+phoneme);
            internuclei.push(phoneme)
        }
    }
  
    
    // Done looping through phonemes. We may have consonants left at the end.
    // We may have even not found a nucleus.
    if (internuclei.length > 0) {

        if (syllables.length == 0) {
            
            syllables.push([ [None], internuclei, [], [] ]);
        }
        else {
            
            extend(syllables[syllables.length-1][3], internuclei);
        }
            
    }
      
    //if(dbug)console.log((syllables));
    
    return _stringify(syllables);
}
  */ 
/*
 * Takes a syllabification and turns it into a string of phonemes, 
 * delimited with dashes, and spaces between syllables 

function _stringify(syllables) {
        
    var ret = [];
    for (var i = 0; i < syllables.length; i++) {
        
        var syl = syllables[i];
        var stress = syl[0][0];
        var onset = syl[1];
        var nucleus = syl[2];
        var coda = syl[3];
      
        if (stress != None && nucleus.length != 0)
            nucleus[0] += (''+stress);
        
        var data = [];
        for (var j = 0; j < onset.length; j++) 
            data.push(onset[j]);
        
        for (var j = 0; j < nucleus.length; j++) 
           data.push(nucleus[j]);
        
        for (var j = 0; j < coda.length; j++) 
           data.push(coda[j]);
        
        ret.push(data.join('-'));
    }
    
    return ret.join(' ');
} */
                
$(document).ready(function () {

    var word = "organizations".toUpperCase();
    var phones = "AO2-R-G-AH0-N-AH0-Z-EY1-SH-AH0-N-Z";
     
    
    test("_stringify", function () {
        var data = [ [   [2], [],     ['AO'], ['R']       ],
                     [   [0], ['G'],  ['AH'], []          ], 
                     [   [0], ['N'],  ['AH'], []          ],
                     [   [1], ['Z'],  ['EY'], []          ],
                     [   [0], ['SH'], ['AH'], ['N', 'Z']  ] ];
        var out =   "AO2-R G-AH0 N-AH0 Z-EY1 SH-AH0-N-Z";       
        equal(RiString('')._stringify(data), out);
    });
    
    test("syllabify(string)", function () {
        
        var test = "AO2-R-G-AH0-N-AH0-Z-EY1-SH-AH0-N-Z";
        var expected =   "AO2-R G-AH0 N-AH0 Z-EY1 SH-AH0-N-Z"; 
        var result = RiString('').syllabify(test);
        deepEqual(result, expected);
    });
    
    test("syllabify(array)", function () {
        
        var test = "AO2-R-G-AH0-N-AH0-Z-EY1-SH-AH0-N-Z".split('-');
        var expected = "AO2-R G-AH0 N-AH0 Z-EY1 SH-AH0-N-Z"; 
        var result = RiString('').syllabify(test);
        deepEqual(result, expected);
    });
    
});
</script>
</head>

<body>
<h1 id="qunit-header">RiTa LTS-vsLexicon</h1>
<h2 id="qunit-banner"></h2>
<div id="qunit-testrunner-toolbar"></div>
<h2 id="qunit-userAgent"></h2>
<ol id="qunit-tests"></ol>
<div id="qunit-fixture">test markup, will be hidden</div>
<p>&nbsp; &nbsp;
<a href="../rita-api.html"><img src="imgs/rita-loading.gif" width=40></a>
</body>

</html>